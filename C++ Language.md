1. **引用的本质是什么？**
    + 引用的本质是指针常量，引用的底层其实就是用指针实现的
    + 定义引用时要对这个指针常量进行初始化
    + C++ 语法上使引用起到了"别名"的效果，其实不过是编译器行为罢了
    + 所谓“引用不占内存”指的是引用不产生新对象，不占对象的内存，然而引用本身作为指针常量是占据内存的

2. **浅拷贝与深拷贝的**
    + 区别只发生在对象有引用外部资源的时候，比如对象中有指向其他区域的指针
    + C++ 编译器默认将指针当成变量，因而默认拷贝（浅拷贝）前后的两个对象中的指针指向同一个外部资源
    + 深拷贝则是重新新建被引用的资源

3. **拷贝与拷贝构造有什么关系？**
    + "拷贝构造"是在没有对象的情况下，在一块新的内存上以另一对象为模板创建对象，只需要复制即可
    + "拷贝"则是要先清理原来对象的内容，该归还的内存要归还，该放弃的锁要放弃，该释放的句柄要释放等等，然后再复制
    + 对于简单的类，二者没有区别，效果相同；而对于复杂的类，不先清理就直接复制可能会导致紊乱

4. **C语言的函数返回值明明有地址，为什么还是被当做右值？**
    + 函数返回值属于临时对象，临时对象在调用结束后，就在栈帧上被弹出了，相对于调用方的栈空间来说，它是不稳定的

5. **右值引用的作用**
    + 右值引用其实就是为了在复制时避免深拷贝，其做法就是将资源所有权转移，因此右值引用常被用来做形参，其只有在对象中包含对外部资源的引用时才会有优势
    + 其优势就是浅拷贝对深拷贝的优势
    + 很多 STL 容器就有对外部资源的引用，因此在 STL 容器传形参时用右值和右值引用可以提高性能
    + 右值引用的优势场景体现在需要立刻接管即将销毁的对象上，例如形惨传递和函数返回值

6. **浮点数存在下溢问题和上溢问题，但整型只存在上溢问题**

7. **implicit 和 explicit**
    + C++ 中没有 implicit 这个关键字，只有 explicit
    + 默认情况下是 implicit，也即允许隐式类型转换
    + 虽然 implicit 好用方便，但有时可能导致意想不到的问题，因此把函数声明为 explicit 可以禁用之
    + 那么问题来了，为什么要搞出一个默认的隐式类型转换？

8. **C++ 和 C 的一个不同之处在于， C 的 main 函数前只是一些变量的配置，只需将静态存储区初始化就可以了（由加载器完成），而 C++ 对象需要执行构造函数，这需要可执行代码，因此 C++ 由 .init 段和 .fini 段（用于析构）**

9. **内存泄露不止会发生在 new-delete 不配对时，还可能发生在继承类对象调用了基类析构函数导致局部销毁时**
    + 因此当应用多态机制时，析构函数最好被声明为虚

10. **被写成 inlined 的函数不一定真的会被 inlined，这取决于编译器**

11. **虚函数不能被 inlined，因为虚函数只有在运行时才知道是哪一个实现**

12. **如果被 inlined 的函数是递归函数会怎样？**
    + inline 不允许被用于递归

13. **inline 在大多数 C++ 程序中是编译期行为，不过也有的可以在链接期甚至运行期进行**

14. **vector 的空间是只增不减的**

15. **为什么 vector 扩容是以倍数增长而非常量？**
    + 原因是每次扩容都涉及到拷贝
    + 扩容次数越多，拷贝次数越多，而以倍数增长可以减少拷贝次数，可以计算出来，当总扩容量很大时，成倍扩容的均摊拷贝次数为常量级，而常量扩容为o(N)
    + 至于以多大倍数扩容则由编译器决定

16. **C++ "return obj();" 发生了什么？**
    1. obj()：在当前 routine 的栈段内创建一个 obj 的临时对象（调用构造函数）
    2. return obj()：将该临时对象拷贝到返回地址上（调用拷贝构造函数）
    + 因此，该语句会调用一次构造函数、一次拷贝构造函数

17. **[续16]将临时对象拷贝到返回地址上这一操作是由谁来完成的？是调用者还是被调用者？**
    + 应该是被调用者，因为如果是调用者，此时由于被调者已经结束，其创建的临时对象也已结束生命周期，因此调用者是做不到的

18. **[续16]若在调用者中有一条语句是"a=fun();"则还要调用一次赋值运算符，而如果是"obj a=fun();"则是还要调用一次拷贝构造函数**

19. **有些 class 被声明出来就是为了被当做基类使用的，有些不是**
    + 被当做基类声明的 class，有些是为了做多态用途的，有些不是
    + 对于被声明用作多态基类的 class，其析构函数必须定义为 virtual，否则会出错
    + 对于不是用作基类声明的 class，其析构函数不应该为 virtual，因为对象携带 vptr 需要额外空间

20. **C++ 对资源的管理，建立在构造函数、析构函数、拷贝构造函数的基础之上**
    + 它们是基石
    + 所谓资源管理，无非是获取、使用和释放，获取在构造函数、拷贝构造函数中完成，释放则在析构函数中进行

21. **C++ 的"对象管理资源"思想：**
    + 单纯依赖程序员将 new 和 delete 成对使用的好习惯是不可靠的，因为既无法保证程序员不犯错误，也无法保证在程序的迭代过程中这一配对被打断（例如中间添加个"return"语句）
    + 解决这一问题的思路在于，把资源的释放放进析构函数之内，由对象的析构机制来自动完成对资源的释放，确保资源不泄露
    + 于是，对象就天然被分成了两大类：管理资源的对象(managing object)，以及被管理的对象(managed object)

22. **让函数返回 reference 在很多情况下并不可取，尽管它效率高：**
    1. 返回 reference 指向 local 对象，其在函数退出后就会自动销毁，这种情况下返回 reference 必然出错
    2. 返回 reference 指向 heap-allocated 对象，不会出错，但难以保证函数调用者会正确释放它们
    3. 返回 reference 指向 static local 对象，不会出错，但有 static local 对象的函数是不可重入的，所以运行时可能结果超出意料
    4. 返回 reference 指向 global 对象，无问题，总而言之， reference 不论是指针还是引用，其所引之物都必须要先保证存在

23. **析构函数的运作方式是：最深层派生的那个 class，其析构函数最先被调用，随后是其每一个 base class 的析构函数被调用**
    + 如果不是摘抄了这句，之前还差点理解反了...
    + 如果最外层的析构函数已经析构了其 base class 的成员，那么在调用到其 base class 的析构函数时会不会出错？
    + 如果是虚析构函数，这种机制还存在吗？

24. **所谓 static，其本意应该是形容生命周期，从进程的开始直到进程结束**
    + 所谓 static 对象，就是指其寿命从被构造出来到进程结束为止。
    + 此类对象包括 global 对象，定义于 namespace 作用域内的对象，在 class 内以及在 file 作用域内被声明为 class 的对象
    + 函数内的 static 对象为 local static 对象，其余皆为 non-local static 对象

25. **static 的作用在于两点：**
	1. 修改链接属性： external -> internal
	2. 修改存储类型： auto -> staitc
	+ 在不同文件中声明的全局变量，在链接时只占用同一个存储单元，如果在不同文件中对齐初始化，则会报错
	+ "int a;" 与 "int a=0;" 并不是同一类型的语句，前者只是声明了一个变量，后者则是重新定义

26. **const 成员函数的作用是什么？**
	1. 声明是在函数之后加 const 关键字，而不是之前
	2. 把一个成员函数声明为 const 的意图在于声明此函数不断算修改对象的成员，于是当编译器发现其有修改的语句时，会报错提醒
	3. const 成员函数的意义在于，当对象被 const 修饰时，它将只能调用 const 成员函数
	4. const 成员函数虽然不能改变对象的成员，但是可以修改类的静态成员
	5. 具体的原理是 const 修饰的是 this 指针，相当于本对象中所有的成员都成了 const，因此不能修改，然而const 并没有修饰类的静态成员，所以它们可以被修改
		+ 放在函数后的修饰符都是对 this 指针的修饰
	6. const 也是函数签名的一部分，因此 "int getA();" 和 "int getA() const;"并不是同一个函数

27. **C++ 智能指针 shared\_ptr 用到的引用计数在什么位置？**
	+ 它也是动态分配的，在堆上，这样做有三个原因：
		1. 引用计数不应放在被指的对象上，因为被指对象不应受指针的影响，它也没地方放引用计数
		2. 引用计数不应放在 shared\_ptr 对象中，因为引用计数要被所有指向同一资源的指针访问，若放在其中，必须作为 static 成员才能被其他智能指针访问到，然而这样就与指向其他对象的 shared\_ptr 冲突了
		3. 动态分配的好处就是巨大的灵活性——它可以为任何对象计数

28. **C++ 不一定比 C 更庞大或迟缓， C++ 在空间和时间上的性能牺牲主要是由多态（或者说 virtual）带来的**

29. **内置类型和自定义类型有什么区别？**
	+ 内置类型对象的初始化直接初始化即可，而自定义类要调用构造函数
	+ 内置类型对象在结束生命周期时，直接从栈上弹出即可，而自定义对象必须调用析构函数，因为其中可能包含栈外资源，必须用析构函数一一释放

30. **C++ iterator和指针是什么关系？**
	+ iterator 是指能够用来遍历容器的工具，从这个角度看，指针也是 iterator 的一种
	+ 然而 iterator 是一种模板类，用来针对不同容器提供遍历接口，只不过 iterator 访问元素的语法 "\*" 和指针很像

31. **为什么构造函数不能是虚函数，而析构函数可以?**
	+ 因为构造函数在建立对象时调用，那时还没有虚函数表，而析构函数调用时已经有了

32. **如何理解 C++ 多态、封装、继承？**
	+ 封装是代码模块化，隐藏细节，继承是扩展已有代码，它们的目的之一都是为了"代码重用"
	+ 而多态的目的则是为了"接口重用"，多态是方法的多态，而不是属性的多态
		+ 多态分两种，编译时多态(重载)，和运行时多态(虚函数)，其实二者的区别就是绑定的时间不一样，严格来说，重载其实不算真正的多态

33. **const + \*, const 在 \* 左边时表示值是常量，在右边表示指针是常量**

