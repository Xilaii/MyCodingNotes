1. **AMD 和 Intel 都用 x86 体系指令集，因此程序可以在两种 CPU 上共用，二者区别不过是硬件电路实现方式不同而已。也就是说，软件开发者所需要考虑到的最底层，就是指令集层，再往下不再在软件开发者考虑范畴之内。**

2. **C 语言有不止一种调用惯例，在调用之前调用方和被调用方要确认好二者所遵从的是同一种调用惯例，否则调用无法正常进行**
    + 通常所选用的是默认调用惯例，其名为 cdecl，其他调用惯例还有 stdcall, fastcall, pascall 等
	+ C++ 还有自己的特殊调用惯例，称为 thiscall

3. **可执行文件为什么被称为"映像文件(image)"？**
    + "映"是"映射的意思"，具体指的是该文件的各个段会被映射到进程的内存空间去这一过程
    + 当然，程序的装载过程分两次映射，第一次是建立进程的虚拟内存空间，即将该空间与物理内存之间建立起页映射，第二次是将可执行文件的各个段映射到进程虚拟内存空间中

4. **对于 linker 来说，符号只有名字和长度，没有类型，类型对 linker 来说是透明的**

5. **不同的 C++ 编译器的符号修饰规则不同，而 C++ 的 runtime 库和用户编译的程序很可能不是由同一编译器产生的，那么如何保证一定可以动态链接成功？**

6. **可执行文件与目标文件格式接近，这是因为，从目标文件到可执行文件只差链接，而链接只是文件内段的拼接和一些地址的重定位，并不改变结构，只改变内容**

7. **对于 linker 而言，变量和函数都一样——统称为符号，因为 linker 的最主要工作是符号重定位，即调整各个地址的值，变量和函数本质上都是地址，因此从 linker 的角度上看，变量和函数没有区别**

8. **可执行文件中段的名字只对 compiler 和 linker 有意义，而对 OS 的 loader 无意义，因为 OS 只关心它的属性和权限**

9. **compiler 按内容产生 sections，依据是内容的语义，linker 把 sections 按 OS 加载时所关心的访问属性合并成 segments，依据是访问属性，这是出于两方面考虑：**
    1. OS 加载时不关心语义，只关心访问属性
    2. 将 sections 合并成 segments 可以减少内部碎片
    3. section 是"链接视图"，segment 是"执行视图"
  
10. **指令跳转分为相对指令跳转和绝对指令跳转，前者不需要重定位，后者需要**

11. **在 ELF 中，共享库的代码段是地址无关的，因此可以实现多个进程共享，然而 DDL并非如此，因此只能在某些情况下被共享**
    + 地址无关是代码被共享的充分条件

12. **heap 是向上增长的，stack 是向下增长的，但二者并不一定会相遇，因为中间的虚拟内存空间还可能存在其他区域（例如动态共享库)**
    + 而且 heap 并非总是向上增长，“堆总是向上增长”的印象来源于早期 Unix，然而 Windows 并不总是如此

13. **将用户参数入栈是运行时库的入口函数来完成的**
    + 入口函数准备好各方面铺垫后，再调用 main()，也就是说 main() 也是需要被调用的，而 main() 函数的返回值正是返回给入口函数的

14. **exit() 是程序退出的必经之路，即使不在 main() 函数中调用之，入口函数也会在调用 main() 之后自动调用 exit()**

15. **C 语言的运行库从某种程度上看是 C 语言的程序和不同 OS 之间的中间层，它将不同 OS 的 API 或者系统调用抽象成相同接口的库函数**

16. **C++ 的一大缺陷是其二进制兼容性不好**
    + 二进制兼容性是链接过程中的概念
    + 二进制兼容性不好体现在不同 C++ 编译器编译出的目标文件经常不能相互链接，目前的两大派系是 GCC 和 Visual C++
    + 二者不兼容的具体原因之一是 GCC 和 Visual C++ 的符号修饰规则不同
    + C++ 的二进制兼容性不好，直接导致它难以被用来实现操作系统

17. **C 语言指针大小的位数与虚拟空间的位数相同**
    + 指针的位数反映了进程所能访问的最大地址范围，因此进程的虚拟地址空间是有限的

18. **立即数之所以叫"立即数"而不是"常数"，是因为 CPU 得到一个地址并不那么容易，它们往往要么在寄存器中，要么在内存中，得到它们需要多花几个周期，如果地址直接在指令中就包含了，那么就可以立即用，这就是"立即"的由来**

19. **8086有特殊意义，是 x86 的开端，x 是变量，代指所有 Intel 86 系列的产品**
    + 8086 中最先出现内存分段机制，80286 开始出现保护模式

20. **syscall 与 CPU 的 dual mode 有什么关系？**
    + dual mode 限定了一些指令的作用类型和范围，使得操作系统能够比普通进程拥有更多特权，从而使 syscall 得以享有"特权"
    + 实际上 CPU 的 mode protection 不只有两种，还可以分出更多层次，只不过通常只用到了两层

21. **局部变量和函数的声明并不会产生任何汇编代码**
	+ 因为它们只是用来提醒编译器

22. **字节对齐往往是由编译器来安排的**
    + GNU 编译器提供 __attribute__() 机制可以为变量、函数类型设置属性，以提供优化选项
	+ __packed__ 和 __attribute__((__packed__)) 作用相同
	+ __packed__ 是不对齐的意思，aligned(4) 则是对齐
	+ 不对齐可以节省内存，对齐可以提升 CPU 的访问效率

23. **const 的常量属性是通过编译器检查语句对企图修改它的语句报错来实现的，还是在运行时利用内存的访问保护机制来实现的？**
    + const 原本只是语法上的变量的修饰符，所以原本只需要在语法上阻止显式修改即可（由编译器在发现试图修改的语句时报错）
		+ 对于栈上的局部动态变量来说，用的就是这种方式，也只能用这种方式，因为栈是动态的，不能给它添加只读属性
	    + 此时虽然不能显式直接修改其值，但仍然可以绕过语句修改之（比如通过指针而不用变量名）
	+ 但编译器有时会对语句进行优化，可能将常变量优化成常量，于是它会被加载到内存中的只读页去，此时运行时的修改就会导致出错（segment fault 或者 core dumpped）

24. **函数的栈上动态局部变量在目标文件的符号表中有符号存在吗？貌似不需要？**
    + 的确是不存在的
	+ 符号表中存放的符号主要是全局符号（用于链接），或者仅仅本编译单元内部可见的局部符号（用于分析程序或者崩溃时的核心转储文件）
	+ 至于栈上的动态局部变量，链接时用不到，而且也无法用于崩溃后分析，并且在程序运行过程中，只需要根据栈底+偏移就可以确认该变量的位置，因此不需要有符号
	+ 这些结论可以通过编写一个简单的文件编译后查看其符号表来验证

25. **不同架构的处理器，其内部硬件结构不同，例如 x86 体系下 PC=CS+IP，PC 不是单独一个寄存器，而是两个寄存器的组合，所以无法用 mov 直接赋值，而是要用 jump，call 这类专用指令，而 ARM 架构则 PC 单独一个寄存器，因此可以用 mov 直接赋值**

26. **值的类型并不是值的本质，所谓类型，无非是其被 CPU 的理解方式**
    + 所有函数都应该有原型，尤其是那些返回值不是整型的函数，因为程序调用一个无法见到原型的函数时，编译器会默认其返回类型为整型

27. **C 语言没有显式的布尔值，所以用整数来代替**
    + 凡是非零值皆为 true（即便是负数），只有0为 false，true 被定义为1，故而不等于1的非零整数虽然都会被判定为 true 但却与 true 不相等

28. **在语言中，有些规则是程序运行中的限制，有些是编译器出于某些考量施加的限制**
    + 对于编译型语言，语言=编译器，在学习它的特性时一定要时刻思考编译器在其中扮演的角色

29. **"int a=10;" 和 "int a;a=10"是不一样的**
	+ 前者是声明一个初值为10的变量
	+ 后者是声明一个变量，再赋值为10
	+ 全局变量的初始化在程序开始运行之前就已经做好，具体做法是将程序加载到内存中时，其静态存储区对应位置的值直接初始化为对应值，而赋值是在程序开始运行之后
	+ 不过对于自动变量来说就是一样的了，因为自动变量本来就是在运行过程中被产生的

30. **字符 I/O 每次读入一读入/输出一个字符，但这个字符用 int 表示而不是 char，因为 EOF 被定义为4字节**

31. **POSIX 与 ISO C 之间的区别是什么？**
	+ ISO C:
		+ 意图是提供 C 程序在不同 OS 间的可移植性
		+ 此标准不仅定义了 C 语言的语法和语义，还定义了标准库
		+ 所有 UNIX 都提供 ISO C 的标准库函数
		+ 这些标准库被分为24个区，分别在24个 .h 文件中被声明
		+ 用 ISO C 写的程序几乎可以在任何环境下运行
		+ ISO C 虽然通用，但不够强大，其标准库只能完成一些很基础的功能
	+ POSIX：
		+ 意图是提升程序在 UNIX 系统之间的可移植性
		+ 该标准说明了一套接口，而不是实现
		+ POSIX 远比 ISO C 大，而且功能更多，POSIX 包含了 ISO C，并添加了更多扩展和限制
		+ POSIX 是针对特定类型 OS 的，基于 POISX 编写的程序可以在任何支持 POSIX 的环境下运行

32. **使用 const 替代 #define 的好处**
	+ #define 定义的符号只有预编译器看到，而编译器看不到，也不会存在于符号表中，因此不方便 debug
	+ #define 定义的常量会出现多份拷贝，浪费内存
	+ const 可封装，而 #define 不可

33. **运行程序时出现 "segment fault" 是什么意思？**
    + A segment fault is a fault raised by hardware with memory protection, notifying OS the software has attempted to access a restricted area of memory(a memory access violation)
	+ 也就是说，"segment fault" 说明程序在试图访问其不该访问的地址，在指针操作中比较容易出现这种情况
	+ 但视图改变 const 常量时却不会出现这种错误，因为视图改变 const 常量的语句根本不会通过编译，这相当于编译器为我们提的醒

34. **CPU 的8个寄存器，虽然都是通用的，但还是约定了它们的惯用方法**

35. **从模块化编程的角度来看，C 函数是 C 语言模块的最小单位**

36. **Linux 下的库不是单一的一个目标文件，而是包含了很多目标文件，加上一个索引的包**
	+ 之所以要包含很多目标文件，是因为每个函数都有单独的目标文件，如果把所有函数都编译成一个目标文件，则过于庞大，在静态链接时会导致很多用不到的函数被链接进去，浪费存储空间
	+ 至于索引，是用来便于检索的
	
37. **C++ 函数签名是为 C++ 命名空间创建的，C 中没有**

38. **gcc 是对预编译器、编译器、汇编器和链接器的封装，根据不同的参数来调用它们**

39. **未初始化的局部静态变量和全局变量的默认值为0，本来它们也可以被放在 .data 段中，但因为它们都是0，所以它们在 .data 段中分配空间并存放0是没必要的**
	+ 所以只需要用一个 .bss 段为它们预留个位置就可以了，故而 ELF 文件的 .bss 段中无内容

40. **有些系统是大端序，有些是小端序**

41. **C++ 中的函数为什么可以重载？**
	+ C++ 函数重载是通过函数签名来实现的，在语言级别它们是同名函数，但编译后它们的函数签名并不相同，链接器根据签名来识别函数
	+ 不同编译器采用不同的函数修饰方法，必然导致不同编译器产生的文件无法正常互相链接

42. **对于链接器来说，变量只有长度，没有类型，因此链接器无法判断变量类型是否一致**

43. **常规的链接是将所有目标文件中的相似段合并，得到可执行文件，但是这种做法会把库文件中的许多没有用到的函数和变量链接进来，浪费空间**
	+ 对于这一问题，Visual C++ 和 GCC 都提供了函数级的链接，但貌似这只针对 C++，而 C 没有
	+ C 语言解决这一问题的办法是库的每个目标文件都只包含一个函数

44. **动态链接库的路径是会写入 ELF 文件中的**

45. **C 语言中字符串常量被存放在 .rodata 段中，受写保护，因此对它的修改会引发 "segment fault"**

46. **ELF 字符串表中的内容是描述段信息的字符，而非程序内用到的字符，后者在 .rodata 段中**

47. **所谓符号，就是地址，具体指程序和变量的起始地址**

48. 
