1. **最初的 OS 是单任务的，每个任务掌控所有资源，OS 支持多任务后，资源分配（一切资源）成了首先要解决的问题；由此，“进程”的概念才有必要被提出来，所谓“进程”，换个角度就等于“任务+资源”。**

2. **个人在做一件事时，时不时抽出一些时间做其他事情，这样虽然ta对单件事情的效率降低，但是对整体所有事情的效率却很可能提升了。操作系统通过中断来打断各个任务也是类似的原理，“中断”虽然是“打断”的意思，但它恰恰是提升整个系统的利用率（而非提升某个任务的完成效率）的最佳方式，也就是说，中断是系统利用率与单个任务完成效率这一对矛盾的折衷方式。**

3. **内存分页和程序分段的关系是什么？**
    + 内存分页是操作系统按一定空间粒度管理内存的机制，由 CS:IP 寄存器实现，分页的依据是页的大小；程序的分段是在程序自己的进程空间中人为按逻辑划分的内存区域，分段的依据通常是语义（例如堆区、代码区、静态存储区等），这是二者的区别
    + 按语义分出的各个程序段，被再次按空间分配到实际的物理页中去，通过页表映射，这是二者的联系
 
4. **实模式和保护模式的关系是什么？**
    + 保护模式和实模式是 x86 体系 CPU 的两种工作模式，具体不同体现在寻址方式、寄存器大小、指令用法等的不同
    + 实模式的存在主要是为了向早期的低位数 CPU 兼容（计算机技术中，由于向后兼容导致的现象比比皆是，工程问题发展历来如此）
    + 实模式相当于一个支持内存分段的大型单片机，而保护模式则有了诸多特权和限制（例如 CPU 特权级），使得操作系统与应用程序之间的地位得以区分开 
    + 开机时，32位 CPU 先处于实模式，之后再进入保护模式，保护模式只有在32位 CPU 中才会出现，与16位机无关，32位 CPU 中有实模式只是为了兼容以往的16位机代码

5. **操作系统就是一个无限循环程序**
    + 操作系统是被动工作的，只有有事件发生才会工作，因此称之为"event-drived"

6. **设计操作系统时，主要有两项指标，user goal 和 system goal，这两项指标通常是相互冲突的，所有现有操作系统，都是这两项指标在面对不同场景和需求下所做出的折衷**

7. **为什么访问文件之前要先 open？**
    + 因为根据文件名查找文件位置是一件耗时的事，因此在内存中用 open-file table 维护已经打开的文件信息，避免频繁查找

8. **磁盘为什么要划分成分区再使用？**
    + 一个磁盘可以分成多个分区，也可以由多个磁盘组成一个分区
    + 分区可以看成是虚拟磁盘，分区是用来建立文件系统的最小单位，文件系统只关心分区，不关心磁盘，分区可以看作协调实际存储设备与文件系统需求的中间层

9. **文件路径之所以叫"路径"，是因为文件系统本身的结构就是一颗树**

10. **目录与目录之间的关系是树形的指向，而不是集合的包含，尽管看起来很像是后者**

11. **所谓 mount，就是将 raw 设备加载或加入到文件系统中的过程，或者将一个文件系统链接成为另一个文件系统的分支的过程**

12. **virtual memory 让每个程序只加载一部分，因此能让同一时刻内，内存中容纳更多进程，从而提高了 degree of multiprogramming**
    + real-time system 通常不使用 virtual memory 机制，因为它可能给 real-time process 引入未知的延迟

13. **不同文件系统如何挂载到同一目录体系之下？**
    + 通过虚拟文件系统(virtual file system)

14. **"The choice is one of policy."**
    + 一个功能通常有很多种策略来实现，具体选择哪一种，有时是出于技术以外的一些因素

15. **所谓资源就是，一旦使用了它，将来必须要还给系统，内存只是资源之一，其他资源还包括文件描述符、互斥锁、网络 sockets 等**

16. **terminal 和 shell 之间是什么关系？**
    + 其实二者根本不是一个范畴的概念
    + terminal 是硬件，是提供输入输出的设备
    + shell 是用户与内核的接口，等同于命令解释器，负责把用户命令用内核可以理解的形式传递给内核
    + 之所以会混淆二者，是因为在用 ubuntu 时，总是在先创建 terminal 再调用 shell，因此容易把它们当作同一种东西，而实际上是，每打开一个 terminal，系统都会将其关联到 shell 上

17. **对 Linux 来说， ELF、shell 脚本、python 脚本等都是可执行文件，而它们的内容格式大不相同，那么 Linux 是如何正确区分并加载、运行它们的？**
    + Linux 加载可执行文件时，会首先检查其前128个字节的内容，这些内容相当于魔术，用来帮助 OS 区分可执行文件的类型，然后 Linux 会针对文件类型调用对应的装载处理过程

18. **overlay 和基于 paging 的虚拟内存都是用来解决物理内存不够的方法，不过 overlay 已经退出历史舞台了**
    + overlay 要根据每个模块的大小，让程序员自己编写装载器，而 paging 则是操作系统自动完成，进程是感觉不到的

19. **paging + virtual memory 给性能带来了深远的影响，由于 demand paing 的存在，在编写程序时， segmentation 变得十分有意义——能大大降低 page-fault rate；对编程语言也有影响，比如 c/C++允许指针指向任意地址，这会引发 page-fault rate 的上升，而不允许指针的 Java 则无此 overhead**

20. **"Virtual memory is the separation of user logical memory from physical memory."**

21. **64位系统的空间特别大，以至于传统的一些算法开销很大（例如页表），所以需要特殊处理（例如多级页表）**
    + 有时32位系统运行某些程序更快，就是这个原因，所以并不是字长越大就越好

22. **trap，exception，interrupt是什么关系?**
    + interrupt 和 trap 是一类，都是在运行过程中遇到了事件（外部事件或内部事件）需要跳转，处理完后再回来继续执行
    + 而 exception 意味着运行过程中出现了错误，需要 OS 去处理（例如缺页异常）

23. **dynamic loading 与 dynamic linking 有什么区别？**
    + dynamic loading 指的是在运行过程中用到哪个 routine 再加载哪个（最开始只加载主要部分），而不是一次性加载所有内容
    + dynamic linking 指的是运行时决定用到哪些模块，再将其映射到本进程的内存空间中，与 static linking 对应
    + 二者概念相似，但说的是不同的方面

24. **操作系统一般放在低地址空间，因为中断向量一般在低空间**

25. **deadlock 的预防和避免需要额外信息，维护这些信息的代价很高昂，而 deadlock 又不那么经常出现，因此不划算，等出现后检测出来再恢复更合适**
    + 所以现代 OS 并没有完全解决 deadlock 问题
    + 尽管 deadlock 的预防和避免是不必要的，但检测确是必要的，因为如果发生了 deadlock 发生了却没有检测到，那么它将会有可能耗尽系统资源

26. **进程同步是由多任务引起的，如果没有多任务，也就不需要进程同步**

27. **deadlock 的预防和避免需要额外信息，维护这些信息的代价很高昂，而 deadlock 又不那么经常出现，因此不划算，等出现后检测出来再恢复更合适**
    + 所以现代 OS 并没有完全解决 deadlock 问题
    + 尽管 deadlock 的预防和避免是不必要的，但检测确是必要的，因为如果发生了 deadlock 发生了却没有检测到，那么它将会有可能耗尽系统资源

26. **进程同步是由多任务引起的，如果没有多任务，也就不需要进程同步**

27. **OS 与 process 的关系：服务、环境、管理**
    + 操作系统对于应用进程来说，有时是提供服务，减轻应用程序的负担，有时是维护环境，比如某些常量，有时是对进程进行管理和限制

28. **要管理文件系统，不仅需要 on-disk data structure，还需要 in-memory datastructure**

29. **如果目录结构采用 acyclic-graph，则有可能导致循环，因此这种结构的目录很少存在**

30. **为什么需要 $PATH？**
    + 因为 Unix 将命令当成可执行文件的装载和执行，为了便于只在特定目录下找命令，定义了命令的搜索顺序，这就是 PATH，PATH是为了将包含命令可执行文件的目录和普通目录区分开来

31. **Windows 的 CRT 是建立在 API 之上的，Linux 的 CRT 是建立在 system call 之上的**
	+ API 是对 system call 的封装
	+ Windows API 是以 DLL 导出函数的形式暴露给开发者的，这些 DLL 的头文件、导出库、相关文件和工具一起称为 SDK

32. **Some operating systems are designed to be convenient, others to be efficient and others some combination of the two.**

33. **系统调用和函数调用虽然名称相似，但二者差距甚远**
    + 系统调用的本质是用户进程通过软中断借助内核完成一些高特权级的任务（例如访问外设），调用的时间成本非常高
	+ 函数调用的本质是是简单的指令跳转，调用成本只是运行时栈的增长和弹出，相对较低
	+ 对用户来说二者形式有时很像，例如 C 语言经常把系统调用封装成与之同名的库函数，此时二者显得非常相似

34. **地址总线位32位，并不能使用全部的 4GB 内存，因为一部分地址被分配给其他硬件了，例如显存，硬盘控制器等，因此 4GB 的内存条最后会只显示为 3.8GB 左右**

35. **只有多核 CPU 才有真正的并行，单核 CPU 只能谈并发**

36. **fork() 调用一次，但返回两次，分别在子进程和父进程中返回一次，用以区分父子进程**
    + fork() 产生的子进程，与父进程的代码完全一样，但是执行并非从头开始，而是从紧接着fork() 的下一条开始，因此用 "fork()" 这一名词来形容这一操作十分形象

37. **程序在独自运行的情况下，多半不会出问题，但一旦存在多个任务共用同一片数据的程序同时运行，就有可能发生不一致或者冲突，换句话说，多任务是导致需要各种保护机制的根本原因**
    + 发生冲突的主要具体原因有三个：
	    1. 某些写操作不是原子的，因而存在在写的过程中被打断修改的可能
		2. 多任务机制引入了打断
		3. 多级存储机制使同一数据存在多个状态

38. **disk 不一定要有 file system 才可以存储数据**
	+ 比如 swap 空间就是 raw disk space，有的 database 也是用 raw disk
	+ 在系统还未加载时，由于没有文件系统驱动，此时是无法对文件系统进行操作的，解决办法是到一段预先定义好的 sequential series of blocks 读指令，利用这些指令来进一步加载操作系统和文件系统
		+ 这段区域被称为 "boot partition"

39. **文件名是提供给用户的，当用 open 调用打开一个文件之后，文件名就没用了，改成 file descriptor 来表标识**
	+ file descriptor，file handle 是一类东西

40. **在 Linux 下，当一个分区没有被挂载时，它是作为一个设备文件存在的，只要将其挂载之后，它才会以目录树的形式依附到根目录上**
	+ 即便被挂载了，它依然是个 device
	+ device 与 device 之上的 file system 在 Linux 眼中是两回事

41. **为什么 TestAndSet() 指令要被设成原子指令？**
    + 同步问题的根源在于打断修改，因此一切解决同步问题的方法本质上都是围绕禁止打断修改来进行，即原子操作
	+ 原子操作最终需要有硬件支持，因此必须有硬件的原子指令
	+ 实现同步所必须的两个操作是“检查+占用”，因此将它设成原子指令，为上层的同步手段提供底层的充分且必要的支持

42. **hard-real time 与 time-sharing 这两种对时间的要求是冲突的**

43. **访问内存对于 CPU 来说是比较慢的动作，效率很低，把零散分布在内存中的信息拼接起来也需要花时间**

44. **Memory is central to the operation of a modern computer system.**

45. **segmentation 和 paging 有什么关系和区别？**
	+ paging 是 OS 管理物理内存的机制，对用户来说是透明的，而 segmentation 是以用户视角来管理内存的机制，用户是清楚的
	+ pages 是等长的，segments 是变长的
	+ paging 是为了解决 contigious allocation 中 external fragmentation 问题的方案，来自 noncontigious allocation，目的是以一定粒度管理物理内存，提高内存利用率并顺便实现保护等功能；segmentation 是为了对程序内容进行语义分割，以共享和保护
	+ paging 有 page table，segmentation 有 segmentation table
	+ 二者往往结合起来用，即 segmentation with paging，分两层访问过程，segmentation 是上层，与用户交道，paging 是下层，与 memory 交道
	+ selector 就是 segmentation with paging 的产物，selector 出于保护和共享的目的，设了许多相关的位，比如程序运行时有时会出现 "segment fault"报错，就是 selector 中的相关位起了作用
	+ segmentation 和 paging 原本都是将 logical address 映射到 physical address 的方式，二者本事平行的两种机制，只不过可以叠起来用

46. **为什么保护模式下，段基址要存在内存的全局描述符表中，而不是在寄存器中，以至于让取地址更加麻烦？**
	+ 因为保护模式下要给内存段添加限制，而这些限制在寸土寸金的寄存器中是存不下的

47. **文件系统中的文件是面向应用的，文件与应用之间缺乏独立性**

48. **平坦模型是相对于分段模型而言的**
	+ 平坦与分段，是一种程序员视角
	+ 分段模型起源于早期 x86 由于地址线扩展，所引入的 "段基址+偏移量" 地址形式，这本身就是一种补丁措施
	+ 而到了32位时代，32位偏移所达到的空间已经很大了，也就是说，一个段的大小已经足够
	+ 平坦模型所指的空间，是虚拟内存空间，也就是程序员看到的进程的虚拟内存空间

49. **C 语言的指针中的地址是虚拟空间中的地址还是物理地址？换句话说， & 取地址操作是可以在运行之前就能知道结果，还是在运行之中才可以？**
	+ 是虚拟地址
	+ CPU 所产生的就是虚拟地址，由 MMU 做地址映射，CPU 是不直接接触物理地址的
	+ 上述是带 MMU 的系统，具体指针指向什么地址，还是要由平台和运行模式来决定

50. **Windows 也是有 swap 空间的，只不过对用户是匿名的，在 C 盘下**
	+ 这应该也是 Windows 出于面向用户的考虑做出的决定

51. **deadlock 出现的原因可以用以下三个原因来描述（不同于经典的四条件）：**
	1. 都太谦让，谦让导致等待
	2. 循环等待，头接尾，导致所有进程都在等别人，也都在让别人等
	3. 每个进程的等待机制都一样
	+ 导致 deadlock 的原因之一是对称（所有进程的等待机制一样），对称就会导致等待环的稳定存在，如果打破对称，则可以防止 deadlcok，但是不对称又可能导致饥饿

52. **进程的状态，阻塞、等待、挂起和休眠之间有什么关系和区别？**
	+ 进程的基本状态是运行、就绪、阻塞（加上创建和死亡）
	+ 阻塞=等待，等待的是公共资源（I/O 和锁等）
	+ 休眠是自己退出调度，过了一定时间后再回来
	+ 挂起是主动想停止运行
	+ 阻塞、挂起、休眠的结果之一，都是从就绪状态中退出

53. **shell 启动某个程序时，会把其后的参数传递给它，这些参数是以初始化栈的形式实现传递的，这个栈中还保存了一些环境变量**
	+ 环境变量是隐式第被 execvp() 系统调用作为参数传递的

54. **允许直接删除一个非空目录与必须先删除其中的文件和子目录，这两种都很容易实现，选哪一种不是技术问题，而是策略问题**
	+ 前者方便但有风险，后者没风险但麻烦

55. **多用户系统就是一台能够并发和独立地执行分别属于两个或多个用户的若干应用程序的计算机。"并发"意味着几个应用程序能够同时出于活动状态并竞争资源，"独立"意味着每个应用程序能执行自己的任务，而无需考虑其他用户在做什么**
	+ 多用户系统的各种特性，必须由底层机制来保证，这一机制就是 CPU 的特权模式

56. 
